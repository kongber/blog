---
title: sm2
createTime: 2025/07/17 15:28:09
permalink: /article/kaf41lah/
---
# SM2密码学：深度解析与拆分应用

## 1. SM2标准操作

SM2算法是中国商用密码标准之一，它基于椭圆曲线密码学（ECC），提供了数字签名、密钥交换和公钥加密等核心功能。SM2的设计考虑了国家安全需求，旨在提供高强度的数据保护和身份认证。本节将深入探讨SM2的各项标准操作。

### 1.1 密钥生成

SM2的密钥生成过程是所有密码操作的基础。它涉及以下步骤：
1. **选择椭圆曲线参数**：SM2标准定义了一组特定的椭圆曲线参数，包括曲线方程、基点 $G$、阶 $n$ 和辅助参数。这些参数是公开且固定的，确保了算法的互操作性和安全性。
2. **生成私钥 $d_A$**：私钥 $d_A$ 是一个随机生成的大整数，其范围在 $[1, n-1]$ 之间。这个私钥必须严格保密，是用户身份的唯一凭证。
3. **计算公钥 $P_A$**：公钥 $P_A$ 是通过将私钥 $d_A$ 与椭圆曲线的基点 $G$ 进行标量乘法运算得到的，即 $P_A = d_A \cdot G$。公钥是公开的，可以安全地分发给任何人。

### 1.2 加密 {#session_enc}

SM2加密是一种非对称加密方案，它允许使用接收者的公钥对数据进行加密，而只有持有相应私钥的接收者才能解密。SM2加密过程通常遵循以下步骤：
1. **随机数生成**：选择一个随机数 $k \in [1, n-1]$。
2. **计算椭圆曲线点**：计算 $C_1 = k \cdot G$。
3. **计算共享秘密**：计算 $S = h \cdot k \cdot P_B$，其中 $P_B$ 是接收者的公钥，$h$ 是一个余因子（通常为1）。如果 $S$ 是无穷远点，则重新选择 $k$。
4. **密钥派生**：从 $S$ 的坐标中派生出对称加密密钥 $t$。
5. **异或操作**：将明文 $M$ 与 $t$ 进行异或操作得到 $C_2$，即 $C_2 = M \oplus t$。
6. **哈希计算**：计算明文的哈希值 $C_3 = Hash(x_2 || M || y_2)$，其中 $(x_2, y_2)$ 是 $S$ 的坐标。
7. **形成密文**：最终的密文由三部分组成：$(C_1, C_2, C_3)$。

### 1.3 解密

SM2解密是加密的逆过程，只有拥有相应私钥 $d_B$ 的接收者才能执行。解密过程如下：
1. **计算共享秘密**：使用私钥 $d_B$ 和密文中的 $C_1$ 计算 $S' = h \cdot d_B \cdot C_1$。如果 $S'$ 是无穷远点，则解密失败。
2. **密钥派生**：从 $S'$ 的坐标中派生出对称加密密钥 $t'$。
3. **异或操作**：使用 $t'$ 对密文 $C_2$ 进行异或操作得到明文 $M' = C_2 \oplus t'$。
4. **验证哈希**：计算解密得到的明文 $M'$ 的哈希值 $Hash(x_2' || M' || y_2')$，并与密文中的 $C_3$ 进行比较。如果两者不相等，则解密失败，表明密文被篡改或私钥不匹配。
5. **输出明文**：如果验证通过，则 $M'$ 就是原始明文。

### 1.4 签名

SM2数字签名提供消息的完整性和发送者的不可否认性。签名过程涉及以下步骤：
1. **预处理**：对签名消息 $M$ 进行预处理，包括将用户的身份信息 $IDA$ 和公钥 $P_A$ 组合，计算一个 $Z_A = Hash(ENTL_A || IDA || a || b || x_G || y_G || x_A || y_A)$，其中 $ENTL_A$ 是 $IDA$ 的比特长度，$a, b, x_G, y_G$ 是椭圆曲线参数，$x_A, y_A$ 是公钥 $P_A$ 的坐标。
2. **计算哈希值**：计算待签名消息的哈希值 $e = Hash(Z_A || M)$。
3. **随机数生成**：选择一个随机数 $k \in [1, n-1]$。
4. **计算椭圆曲线点**：计算点 $(x_1, y_1) = k \cdot G$。
5. **计算 $r$**：计算 $r = (e + x_1) \pmod n$。如果 $r=0$ 或 $r+k=n$，则重新选择 $k$。
6. **计算 $s$**：计算 $s = (d_A \cdot (e + x_1) - k) \cdot (1 + d_A)^{-1} \pmod n$。如果 $s=0$，则重新选择 $k$。
7. **形成签名**：数字签名由一对整数 $(r, s)$ 组成。

### 1.5 验签 {#session_vfy}

验签是验证SM2数字签名有效性的过程，确保消息的完整性和签名者的身份。验证过程如下：
1. **预处理**：与签名过程类似，计算 $Z_A = Hash(ENTL_A || IDA || a || b || x_G || y_G || x_A || y_A)$。
2. **计算哈希值**：计算待验证消息的哈希值 $e = Hash(Z_A || M)$。
3. **验证 $r, s$ 范围**：检查签名中的 $r, s$ 是否在 $[1, n-1]$ 范围内。
4. **计算 $t$**：计算 $t = (r+s) \pmod n$。如果 $t=0$，则验证失败。
5. **计算椭圆曲线点**：计算点 $(x_1', y_1') = s \cdot G + t \cdot P_A$。
6. **计算 $R$**：计算 $R = (e + x_1') \pmod n$。
7. **比较**：如果 $R=r$，则签名验证成功；否则，验证失败。

## 2. SM2 拆分应用

“SM2拆分”通常指的是将SM2算法的某些核心功能或密钥管理环节进行分布式或多方协同处理，以提高系统的安全性、容错性或实现更复杂的信任模型。这种拆分是基于密码学中的多方计算（MPC）和门限密码学概念。

### 2.1 拆分密钥

第一通信方：
1. **生成私钥：** $D1$ 是一个随机生成的大整数，其范围在 $[1, n-1]$ 之间。
2. **生成公钥：** 计算在 $Fq$ 上的逆元 $D1⁻¹$，并计算点 $P1 = D1⁻¹ * G$, 将 $P1$ 发送给第二通信方。

第二通信方：
1. **生成私钥：** $D2$ 是一个随机生成的大整数，其范围在 $[1, n-1]$ 之间。
2. **生成公钥：** 计算在 $Fq$ 上的逆元 $D2⁻¹$，并计算最终的公钥 $P2 = D2⁻¹ * P1 - G$，将 $P2$ 公钥作为公钥。

### 2.2 拆分加密

加密则与 SM2 加密方式相同，可以参考 [SM2 加密](#session_enc)

### 2.3 拆分解密

第一通信方：

1. **子私钥生成**：第一通信方生成自身的子私钥 $D1$，第二通信方生成自身的子私钥 $D2$。
2. **第一部分解密**：第一通信方从密文 $C$ 中提取出比特串 $C1$，并验证 $C1$ 是否为椭圆曲线 $E$ 上的非无穷远点。若验证通过，计算 $T1 = D1⁻¹ * C1$，并将 $T1$ 发送给第二通信方。
3. **第二部分解密**：第二通信方接收 $T1$ 后，计算 $T2 = D2⁻¹ * T1$，并将 $T2$ 发送给第一通信方。
4. **完整解密**：第一通信方接收 `T2` 后，计算 `(x2, y2) = T2 - C1` [cite: 1][cite_start]。然后通过预定的密钥派生函数 `KDF(x2 || y2, klen)` 得到对称解密密钥 `t` [cite: 1][cite_start]。接着，从密文 `C` 中提取出比特串 `C2` [cite: 1][cite_start]，计算 `M'' = C2 ⊕ t` 得到部分明文 [cite: 1][cite_start]。最后，第一通信方计算 `Hash(x2 || M'' || y2)` 得到 `u` [cite: 1][cite_start]，并与密文中的 `C3` 进行比较 [cite: 1][cite_start]。如果 `u` 等于 `C3`，则将 `M''` 作为完整的明文输出 [cite: 1]。

### 2.3 拆分签名

1. **子私钥生成**：第一通信方生成自身的子私钥 $D1$，第二通信方生成自身的子私钥 $D2$。
2. **第一方操作**：第一通信方生成待签名消息 $M$ 的消息摘要 $e$ (通过 $Hash(Z || M')$，其中 $Z$ 是共同身份标识) 和第一部分签名 $Q1 = k1 * G$ ( $k1$ 为随机数) 。随后将 $e$ 和 $Q1$ 发送给第二通信方。
3. **第二方操作**：第二通信方收到 $e$ 和 $Q1$ 后，生成随机数 $k2$ 和 $k3$。计算 $Q2 = k2 * G$。然后计算 $(x1, y1) = k3 * Q1 + Q2$，并计算 $r = (x1 + e) mod n$。如果 $r$ 不为 0，则计算 $s2 = (D2 * k3) mod n$ 和 $s3 = (D2 * (r + k2)) mod n$。最后，第二通信方将 $r$, $s2$, $s3$ 发送给第一通信方。
4. **完整签名生成**：第一通信方接收 $r$, $s2$, $s3$ 后，根据自身的子私钥 $D1$ 和随机数 $k1$，计算 $s = ((D1 * k1) * s2 + D1 * s3 - r) mod n$。如果 $s$ 不为0且不等于 $n-r$，则将 $(r, s)$ 作为完整签名输出。

### 2.4 拆分验签

验签则与 SM2 验签方式相同，可以参考 [SM2 验签](#session_vfy)
加密则与 SM2 加密方式相同，可以参考 [SM2 加密](#session_enc)