# 设计模式

## 1. 设计原则 

7 大设计原则

| 设计原则 | 核心思想 | 示例/说明 |
|---------|---------|-----------|
| 单一职责原则 (SRP) | 一个类只负责一个功能领域中的相应职责 | 将包含数据库连接、CRUD操作、数据导出的类拆分成三个独立的类 |
| 开闭原则 (OCP) | 软件实体应该对扩展开放，对修改关闭 | 新增功能时通过扩展代码实现，而不是修改原有代码 |
| [里氏替换原则 (LSP)](./LSP.md) | 子类必须能够替换其基类 | 子类可以扩展父类功能，但不能改变原有功能<br> 子类出现的地方，父类一定能够替换 |
| [接口隔离原则 (ISP)](./ISP.md) | 使用多个专门的接口，而不使用单一的总接口 | 客户端不应依赖不需要的接口<br> 类之间的依赖应建立在最小接口上 |
| [依赖倒置原则 (DIP)](./DIP.md) | 高层模块不应依赖低层模块，两者都应依赖其抽象 | 抽象不应依赖细节，细节应依赖抽象<br> 面向接口编程，而不是面向实现编程 |
| [迪米特法则 (LoD)](./LoD.md) | 一个对象应该对其他对象保持最少的了解 | 只与直接朋友交谈，降低类与类之间的耦合度；<br>|
| [组合/聚合复用原则 (CARP)](./CARP.md) | 尽量使用组合/聚合，而不是继承关系达到复用目的 | 避免继承导致的高耦合<br> 使用组合和聚合使系统更灵活 |

## 2. 设计模式

设计模式是软件开发中常见问题的典型解决方案。它们是经过反复验证的代码设计经验的总结，能够帮助我们写出更加可维护和可扩展的代码。

23 种设计模式

### 2.1 创建型模式
- [单例模式（Singleton）](./Singleton.md)：确保一个类只有一个实例，并提供全局访问点。
- 工厂方法（Factory Method）：定义一个用于创建对象的接口，但让子类决定实例化哪个类。
- 抽象工厂（Abstract Factory）：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
- 建造者（Builder）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
- 原型（Prototype）：通过复制现有实例来创建新对象，而无需通过实例化类来完成。

### 2.2 结构型模式
- 适配器（Adapter）：将一个类的接口转换成客户希望的另一个接口，使原本由于接口不兼容而不能一起工作的类能够一起工作。
- 桥接（Bridge）：将抽象部分与实现部分分离，使它们都可以独立地变化。
- 装饰（Decorator）：动态地给一个对象添加一些额外的职责，而不会影响其他对象。
- 外观（Facade）：为子系统中的一组接口提供一个一致的界面，使子系统更加易用。    
- 享元（Flyweight）：运用共享技术有效地支持大量细粒度的对象。
- 代理（Proxy）：为其他对象提供一个代理以控制对这个对象的访问。
- 组合（Composite）：将对象组合成树形结构以表示“部分-整体”的层次结构。

### 2.3 行为型模式
- 观察者（Observer）：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。
- 策略（Strategy）：定义一系列算法，将每个算法封装起来，并使它们可以相互替换。
- 模板方法（Template Method）：定义一个算法的骨架，将一些步骤延迟到子类中实现。
- 命令（Command）：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化。
- 状态（State）：允许一个对象在其内部状态改变时改变它的行为。
- 职责链（Chain of Responsibility）：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。       
- 解释器（Interpreter）：给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。
- 中介者（Mediator）：定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。
- 访问者（Visitor）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
- 备忘录（Memento）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
- 迭代器（Iterator）：提供一种方法来访问一个聚合对象中的各个元素，而又不暴露其内部的表示。

